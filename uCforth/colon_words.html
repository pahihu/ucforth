<html>
<head>
<title>colon_words.html</title>
<META NAME="Author" CONTENT="Charles Esson">
<META NAME="keywords" CONTENT="forth">
<META NAME="description" CONTENT=" uCforth uses this file to generate uCforth">
<LINK REL=stylesheet HREF="forth.css" TYPE="text/css">
</head>
<body>
<a HREF="./license.html">license</a>
<a name="cell"></a>
<h5>cell ( --n)</h5>
<p>
Size of cell in address units.
</p>

<pre>
<code>
4 CONSTANT cell
</code>
</pre>

<a name="4*"></a>
<h5>4* ( x1--x2)</h5>
<p>
Multiply input by 4.
</p>
<pre>
<code>
: 4*
	2 LSHIFT
;
</code>
</pre>


<a name="cell/"></a>
<h5>cell/ ( n -- cells)</h5>
<p>
	Take address units and convert back to cells.
</p>
<pre>
<code>
: cell/ ( n -- cells)
	4/
;
</code>
</pre>


<a name="8*"></a>
<h5>8* ( --n)</h5>
<p>
Input by 8.
</p>
<pre>
<code>
: 8*  ( x1 -- x2)
	3 LSHIFT
;
</code>
</pre>


<a name="8/"></a>
<h5>8/ ( x1--x2)</h5>
<p>
Input divided by 8.
</p>
<pre>
<code>
:  8/  ( x1 -- x2)
	3 RSHIFT
;
</code>
</pre>


<a name="16*"></a>
<h5>16* ( x1--x2)</h5>
<p>
Input by 8.
</p>
<pre>
<code>
: 16* ( x1 --x2)
	4 LSHIFT
;
</code>
</pre>


<a name="16/"></a>
<h5>16/ ( x1--x2)</h5>
<p>
Input divided by 16.
</p>
<pre>
<code>
: 16/  ( x2 -- x2)
	4 RSHIFT
;
</code>
</pre>


<a name="2+"></a>
<h5>2+ ( n1|u1--n2|u2)</h5>
<p>
Two is added to the input.
</p>
<pre>
<code>
: 2+  ( u1|n1 -- u2|n2)
	2 +
; inline
</code>
</pre>


<a name="2-"></a>
<h5>2- ( n1|u1--n2|u2)</h5>
<p>
Two is subtracted from the input.
</p>
<pre>
<code>
: 2-  ( u1|n1 -- u2|n2)
	2 -
; inline
</code>
</pre>


<a name="3+"></a>
<h5>3+ ( n1|u1--n2|u2)</h5>
<p>
Three is added to the input.
</p>
<pre>
<code>
: 3+  ( u1|n1 -- u2|n2)
	3 +
; inline
</code>
</pre>


<a name="4+"></a>
<h5>4+ ( n1|u1--n2|u2)</h5>
<p>
Four is added to the input.
</p>
<pre>
<code>
: 4+  ( u1|n1 -- u2|n2)
	4 +
; inline
</code>
</pre>


<a name="4-"></a>
<h5>4- ( n1|u1--n2|u2)</h5>
<p>
Four is subtracted from the input.
</p>
<pre>
<code>
: 4-  ( u1|n1 -- u2|n2)
	4 -
; inline
</code>
</pre>


<a name="3*"></a>
<h5>3* ( n1|u1--n2|u2)</h5>
<p>
Input is multipied by 3.
</p>
<pre>
<code>

: 3*  ( u1|n1 -- u2|n2)
	3 *
;
</code>
</pre>


<a name="8+"></a>
<h5>8+ ( n1|u1--n2|u2)</h5>
<p>
Eight is added to the input.
</p>
<pre>
<code>
: 8+ ( u1|n1 -- u2|n2)
	8 +
; inline
</code>
</pre>


<a name="8-"></a>
<h5>8- ( n1|u1--n2|u2)</h5>
<p>
Eight is subtracted from the input.
</p>
<pre>
<code>
: 8- ( u1|n1 -- u2|n2)
	8 -
; inline
</code>
</pre>


<a name="dup@"></a>
<h5>dup@ ( a-addr--a-addr value)</h5>
<p>
Duplicate the top stack item and fetch the data.
</p>
<pre>
<code>
: dup@ ( addr -- addr 32b )
	DUP @
; inline
</code>
</pre>


<a name="3dup"></a>
<h5>3dup ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )</h5>
<p>
Top three stack items a duplicated..
</p>
<pre>
<code>
: 3dup ( a b c -- a b c a b c)
	2 PICK 2 PICK 2 PICK
;
</code>
</pre>


<a name="$move"></a>
<h5>$move ( addr1 addr2 max--)</h5>
<p>
Move the counted string pointed to by addr1 to addr2, the length of the data area
at addr2 is given by max.<br>
max includes the character count. It is the receiving data area length
</p>
<pre>
<code>
: $move ( $ addr2 buffer_size --)
	2 PICK COUNT 1 + CHARS
	NIP MIN \ $ addr min(--
	2DUP 2>R
	MOVE
	2R> bytes>chars 1- SWAP C!
;
</code>
</pre>
<a name="dgt"></a>
<h5>d></h5>
<p>
Signed compare two double numbers.  If d1 > d2 , return TRUE.
</p>

<pre>
<code>
: d&gt;            ( d1 d2 -- f )
	2SWAP D&lt;
;
</code>
</pre>

<a name="not"></a>
<h5>not ( n1|u1--n2|u2)</h5>
<p>
Just like 0=, documents the fact that you expected a flag.
See also <a HREF="#0=">0=</a> , <a HREF="#INVERT">INVERT</a>
and <a HREF="#NEGATE">NEGATE</a>.
</p>
<pre>
<code>
: not  ( flag -- flag1)
	0=
;
</code>
</pre>
<a name="u&gt;d"><h5>u&gt;d</h5>
</a>
<p>
Change unsigned number to double.
</p>

<pre>
<code>
: u&gt;d ( u --dl dh )
	0
; inline
</code>
</pre>
<a name="d&gt;u"></a>
<h5>d&gt;u</h5>
<p>
Change double to unsigned, no error checking
</p>

<pre>
<code>
: d&gt;u ( u --dl dh )
	DROP
; inline
</code>
</pre>


<a name="u/mod"></a>
<h5>u/mod ( u1 u2 -- rem quot )</h5>
<p>
Two unsigned numbers are divided and the remainder and quotent are returned.
</p>

<pre>
<code>
: u/mod ( u1 u2 -- rem quot )
	&gt;R u&gt;d R&gt; UM/MOD
;
</code>
</pre>


<a name="mu/mod"></a>
<h5>mu/mod ( d1 u -- rem d2 )</h5>
<p>
A double number is divided and a remainder and double number are returned.
This is used in # . The divider is the contents of BASE the remainder is a
character. The number returned is what remains after the division.
</p>
<pre>
<code>
: mu/mod   ( lo hi u -- rem lo hi )
	&gt;R zero  R@           \ lo hi zero u
	UM/MOD                \ lo rem quot (--
	R&gt;                    \ lo rem quot u(-
	SWAP                  \ lo rem u quot (--
	&gt;R                    \ lo rem u (--
	UM/MOD                \ rem quot (--
	R&gt;                    \ rem l h (--
;
</code>
</pre>


<a name="2**"></a>
<h5>2** ( n1 -- x1 )</h5>
<p>
Raise 2 to the specified power
</p>
<pre> <samp>
	2 2** -> 4
</samp> </pre>
<pre>
<code>
: 2** ( n - x1)
	one SWAP LSHIFT
;
</code>
</pre>


<a name="@execute"></a>
<h5>@execute ( a-addr--  )</h5>
<p>
A value is fetched form address, if non zero it is used as a
execution token.
</p>
<pre>
<code>
: @execute ( addr --)
	@ ?DUP IF
		EXECUTE
	THEN
;


: vector ( entry table --)
	TUCK
	@ SWAP 1+ MIN CELLS + @execute
;
</code>
</pre>
<h3>Additional shift operators</h3>
<a name="&gt;asl"></a>
<h5> >asl ( value -- asl_value )</h5>
<p>
Work out the asl value required to set the
highest bit set in the value supplied.
</p>
<pre>
	eg:  4 &gt;asl -&gt; 2     2 2** -&gt; 4
	     5 &gt;asl -&gt; 2
</pre>
	<pre> <code>
: &gt;asl ( value -- asl_value)
	zero SWAP                 \ count value (--
	BEGIN
		1 RSHIFT
		DUP not IF
			DROP
			EXIT
		THEN
		SWAP 1+ SWAP
	AGAIN
;
</code>
</pre>
<a name="$&lt;&lt;"></a>
<h5> << ( x1 u --x2)</h5>
<p>IEEE1275</p>
<p>
Synonym for lshift
</p>
<pre>
<code>
	: &lt;&lt; ( x1 u --x2)
		LSHIFT ; inline
</code>
</pre>

<h5> &gt;&gt; ( x1 u --x2)</h5>
<p>IEEE1275</p>
<p>
Synonym for rshift
</p>
<pre>
<code>
: &gt;&gt; ( x1 u --x2)
	RSHIFT
; inline
</code>
</pre>
\ <a name="-leading"></a>
<p>
Remove leading blanks
</p>
<pre>
<code>
: -leading  { ( variable _%addr ) variable _%number -- ( a2 n2 ) }
	_%number @ zero DO
		DUP C@ BL &lt;&gt; IF
			_%number @ I -
			UNLOOP
			EXIT
		THEN
		1 CHARS +
	LOOP
	\ get to here nothing but blank
	zero
;


CREATE NULL 0 t,

\ <a name="$="></a>
: $=  ( addr addr -- flag)
	2DUP C@ SWAP C@ &lt;&gt; IF
		2DROP FALSE EXIT
	THEN
	DUP C@ &gt;R
	1 CHARS + SWAP 1 CHARS +
	R&gt; zero DO
		OVER C@ OVER C@ &lt;&gt; IF
			2DROP
			UNLOOP
			FALSE
			EXIT
		THEN
		1 CHARS +
		SWAP
		1 CHARS +
	LOOP
	2DROP
	TRUE
;

\ <a name="$make"></a>
\ convert a stack described string to a counted string
\ The inverse of COUNT
: $make  ( source number destination --)
   2DUP C!
   1 CHARS  + SWAP MOVE
;

\ <a name="-$trailing"></a>
: -$trailing ( addr --)
	COUNT -TRAILING SWAP 1 CHARS - C!
;

\ <a name="$&lt;"></a>
_#less -1 ??=
: $&lt; ( $1 $2 --flag)
	SWAP COUNT ROT COUNT COMPARE 0&lt;
;

\ Non standard
\ <a name="$&gt;"></a>
_#greater 1 ??=
: $> ( $1 $2 --flag)
	SWAP COUNT ROT COUNT COMPARE 0>
;

\ <a name="$+"></a>
: $+ { ( $1 $2 ) variable %addr  variable %buffer_length -- }{
	variable %base
	variable %total_count }
	%addr @ %base !
	\ room for count
	[ 1 CHARS NEGATE ]T LITERAL %buffer_length +!
	1 CHARS %addr +!

	SWAP COUNT %buffer_length @ MIN DUP %total_count !
	%addr @ SWAP MOVE
	\ $2(--
	%total_count @ NEGATE %buffer_length +!
	%total_count @ %addr +!
	COUNT %buffer_length @ MIN DUP %total_count +!
	%addr @ SWAP MOVE
	%total_count @ %base @ C!
;


\ <a name="unaligned!"></a>

\ The coldfire can handle unaligned operations
: unaligned! ( value addr --)
	!
; inline

\ <a name="unaligned@"></a>
: unaligned@ ( addr --)
	@
; inline

\ <a name="unalignedW@"></a>
: unalignedW@ ( addr --)
	w@
; inline

\ <a name="unalignedW!"></a>
: unalignedW! ( addr --)
	w!
; inline




</code>
</pre>
<a name="cell_aligned"><h5>cell_aligned ( addr1 -- addr2 )</h5></a>
<pre>
<code>
: cell_aligned ( addr -- a-addr)
	3 + -4 AND
;

</code>
</pre>
<a name="line_aligned"><h5>line_aligned ( addr1 -- addr2 )</h5></a>
<pre>
<code>
\ line aligned, needed for fast DMA
: line_aligned ( addr -- a-addr)
	$0F + -$10 AND
;

</code>
</pre>


</body>
</html>
