<html>
<head>
<title>colon_words_used_by_ansi.html</title>
<META NAME="Author" CONTENT="Charles Esson">
<META NAME="keywords" CONTENT="forth"> 
<META NAME="description" CONTENT=" Used to generate uCforth">
<LINK REL=stylesheet HREF="forth.css" TYPE="text/css">
</head>

<body>
<a HREF="./license.html">license</a>
<a name="zero"></a>
<h5>zero ( --0)</h5>
<p>
Traditionally forths have redefined common used numbers as words, this system
provides the words. They used to compile faster, they offer no advantage except
to make an old man feel good about his code.
</p>

<pre>
<code>
	0 CONSTANT zero
</code>
</pre>

<a name="one"></a>
<h5>one ( --1)</h5>
<p>
Traditionally forths have redefined common used numbers as words, this system
provides the words
</p>

<pre>
<code>
	1 CONSTANT one
</code> 
</pre>
<a name="4dup"></a>
<h5>4dup</h5>
<p>
	Duplicate the top four stack items.
</p>

<pre> 
<code>
	: 4dup  ( a b c d -- a b c d )
		2OVER 2OVER
	;
</code>
</pre>

<a name="jump"></a>
<h5>jump</h5>
<p>
	Third stack item copied to the top.
</p>

<pre>
<code>
	: jump ( a b c -- a b c a )
		2 PICK
	;
</code>
</pre>
<a name="byte!"></a>
<h5>byte!</h5>
<p>
ANSI forth has no byte words.
</p>
<pre>
<code>
	: byte! ( byte addr -- )
		C!
	;  inline \ renamed zero over head
</code>
</pre>
<a name="byte@"></a>
<h5>byte@</h5>
<p>
ANSI forth has no byte words.
</p>
<pre>
<code>
	: byte@ ( addr -- byte )
		C@
	; inline
</code>
</pre>
<p>
You use <i>CHAR</i> to get from characters to bytes, you use <i>byte&gt;char</i>
to get from bytes to characters.
</p>
<pre>
<code>
	: bytes&gt;chars ( n -- n2)
	; inline
</code>
</pre>
</body>
</html>

