<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>uCforth chapter 1</TITLE>
        <META NAME="AUTHOR" CONTENT="Charles Esson">
        <META NAME="keywords" CONTENT="uCforth">
</HEAD>
<BODY bgcolor=#ffffff>
<h1>uCforth Manual chapter 1</h1>
<h3>Index</h3>
<ul>
<li><a HREF="#introduction"><b>Introduction</b></a></li>
<li><a HREF="#type_setting"><b>Type Setting Conventions</b></a></li>
<li><a HREF="#starting"><b>Starting</b></a></li>
<li><a HREF="#making_app"><b>Making a binary application</b></li>
<li><a HREF="#cross_compiling"><b>Cross Compiling</b></a></li>
<li><a HREF="#startup"><b>Forth startup</b></a></li>
</ul>
<a name="introduction">
<h3>Introduction</h3>
<p>
You can look upon <b>FORTH</b> as a super charged bash shell. Forth comes with an interpretor
a compiler and an assembler. All this fits in less than 200k of memory.
</p>
<p>
A libary based version of uCforth is available. If this is used most of the code sits
in the libary and the separate applications created only contain
the application code.
</p>
<p>
In this day and age FORTH is not a common language so I suppose the first
place to start is; why FORTH?.
</p>
<p>
You want to write a little routine to exercise your dual port memory. With C
you write your program, cross compile your program, load your program, debug
you program, and so on and so on. I am sure we have all done it.
</p>
<p>
With FORTH you get it <a href="#starting">started</a>, and then type in:
</p>
<pre>
<samp>
: fred $210000 $200000 DO
		I W@ DROP
	LOOP
;
fred
</samp>
</pre>
<p>
The stuff between : and ; is using the compiler to create a new word. When you type in
<samp><b>fred</b></samp> the word is executed. Your test is running in 30 seconds instead of
30 minutes, thats one reason why you will want to run uCforth.
</p>
<p>
Your on site, no linux host system, no BDM module, the system doesn't work.
You remember you had the forsight to add ucf and the forth script ( less than 200k of code)
to your application. You fire it up, and play. Thats the second reason why you use forth.
You can deliver a very effective debugging tool with the production system.
</p>
<p>
With a megabyte of dram costing about 50 cents footprint is no longer a big issue,
FORTH has a small footprint . We can all afford the code size that is generated by a C compiler.
We cannot all afford the inconvenience when testing hardware and developing small applications.
</p>


<a name="type_setting"><h3>Type setting conventions</h3></a>
<p>
You can't start a manual without going on about type setting conventions. It's always there.
There must be someone who cares.
</p>
<table>
<tr><th>Style</th><th>Who</th></tr>
<tr><td><samp><i>some text</i></samp></td><td>computer</td></tr>
<tr><td><samp><b>some text</b></samp></td><td>You</td></tr>
<tr><td><samp>   some text    </samp></td><td>me</td></tr>
</table>
<a name="starting">
<h3>Starting uCforth</h3>
<p>
To get the self contained version of forth running, move the files <i>ucf</i> and <i>forth</i> to
a device that can be mounted by your uClinux system. Execute <i>forth</i> from your bash shell.
<i>ucf</i> is a bFLT binary file that can be loaded by the uClinux system. <i>forth</i> is a script
that uses <i>ucf</i> to interpret the script. The last thing ./ucf does before exiting is
execute the word whose execution token is stored in <i>'restart</i>. If you take a close look at the
<i>forth</i> script you will see the code: <samp>' QUIT 'restart !</samp>. <i>QUIT</i> does not
exit, it interprets and compiles code entered from the unix input device. If you started forth
from the local terminal the input device will be th local terminal, if you started forth from
a telnet session the input will come from the telnet session.
</p>
<p>
<i>forth</i> is a script that uses <i>ucf</i> as the script interpretor. <i>ucf</i> is a
pretty complete subroutine threaded ANSI forth implementation.
</p>
<p>
If you are new to <b>FORTH</b> you should now go and read <a href="./chanper2.html">chapter 2</a>.
</p>
<h4>The library version</b>
<p>
<i>uCforth</i> comes in two flavors, one that is self contained, and another that is an application
running on the library <i>ucf_lib</i>. The second version is intended for serious work.
If multiple uCforth processes are running on the library version they will use the common library.
As the common library is about 180K this reduces the memory requirement of your system considerable.
</p>
<p>
To use the library version <i>ucf_lib</i> must be installed on the uClinux system as
" <i>/lib/lib3.so</i> ".
As uClinux systems often have there file system in prom this will require a uClinux kernel recompile.
</p>
<p>
The library version of uCforth is started using the script <i>4th</i>.
</p>

<a name="making_app">
<h3>Making a binary application</h3>
<p>
This is an advanced topic, if your just starting to to <a href="./chanper2.html">chapter 2</a>.
<ul>
<li>Start the self contained version of forth or the version that runs on the libary
using the script <i>4th</i>, or <i>forth</i>.</li>
<li>Load the file containing the code to be added.</li>
<li>Set word to be executed when the application is loaded with
the code: <samp>' name 'restart !</samp>. Where name is the name of the word that
performs the desired action.</li>
<li>Make the app with the code: <samp>make_app file_name</samp></li>
</ul>
<p>
For example:
</p>
<pre>
<samp></i>FE10> </i></samp><samp>include my_app.html</samp>
<samp></i>FE10> </i></samp><samp>' my_app_word 'restart !</samp>
<samp></i>FE10> </i></samp><samp>make_app my_app </samp>
</pre>
<p>
The last two steps can be code in your load file if you desire.
</p>
<p>
<i>my_app</i> makes a binflat file based on the currently loaded application.
</p>
<p>
The application created can be started as a separate process from bash.
</p>

<a name="cross_compiling">
<h3>Cross compiling from uCforth</h3>
<p>
To create a new kernel using uCforth mount the full source, change the working directory
so you can start uCforth from the source directory with the command <samp>./forth</samp>,
start forth and type:
</p>
<samp>INCLUDE ./kernel</samp>
<p><samp>./kernel</samp> is a forth file that
sets up uCforth for the cross_compile and loads
<samp><a href="../kernel.html"><i>kernel.html</i></a></samp>.
<samp><i>kernel.html</i></samp> is the kernel source file.
<h3>Cross compiling using Gforth</h3>
<p>
Obviously you can't cross compile using uCforth unless uCforth exists. Development was done
under Gforth. Cross compiling under Gforth will continue to be supported.
</p>
<ul>
<li>Install Gforth</li>
<li>Make the <i>uCforth</i> directory a sub directory of <i>Gforth</i>.</li>
<li>Make the <i>Gforth</i> your current directory with the <samp>cd</samp> bash command.</li>
<li>Start <i>Gforth</i> with the command <samp>./Gforth -m 1M</samp>. The flag tells Gforth
to start with a reasonable sized dictionary.</li>
<li>Load th cross compiling code with the command <samp>INCLUDE
<a href="../kernel.fs">./uCforth/kernel.fs</a></samp></li>
</ul>
<p>
The file loaded sets Gforth up for the cross_compile and then loads
<a href="../kernel.html"><i>Kernel.html</i></a>, which contains the
kernel source common to the Gforth and uCforth cross compiles.
</p>

<a name="startup">
<h3>ucf or ucf_app startup</h3>
<p><i>ucf</i> contains the lib and the app. <i>ucf_app</i> needs
<i>ucf_lib</i> to be installed as <i>/lib/lib3.so</i>. The startup behavior of both is the same.
The rest of this section will refer to the application as <i>ucf</i>.
</p>
<p>
<i>ucf</i> is a script interpreter. Its default behavior is to interpret the script file and exit.
If the script file stores an execution token into <i>'restart</i>, 
the script interpretor will close the script file and execute that token on exit. 
If the token executed never exits then the script never exits.
</p>
<p>
<a href="../forth"><i>forth</i></a> is a script that takes advantage of all this to
bring up a <i>forth</i> prompt.
</p>
</body>
</html>
